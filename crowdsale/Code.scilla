(* CrowdSale contract *)

import ListUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library CrowdSale

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let success = Int32 1
let failure = Int32 2
let low_bal = Int32 3
let _zero=Int32 0

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract CrowdSale
(_wallet: ByStr20,
_rate: Uint256 )

  (* How many token units a buyer gets per wei.*)
  (* The rate is the conversion between wei and the smallest and indivisible token unit.*)
  (* So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK*)
  (* 1 wei will give you 1 unit, or 0.001 TOK.*)


field _weiRaised: Uint256 = "0"

(*shows which beneficiary has sent how many tokens*)
field sale : Map ByStr20 Uint128 = Emp ByStr20 Uint128

(*shows balance of each address*)
field balances : Map ByStr20 Uint128 = Emp ByStr20 Uint128


transition wallet()
    msg = {_tag : "Main"; _recipient : _sender; _amount : Uint128 0; wallet : _wallet};
    msgs = one_msg msg;
    send msgs
end


(* @return the number of token units a buyer gets per wei.*)
transition rate()
    msg = {_tag : "Main"; _recipient : _sender; _amount : Uint128 0; rate : _rate};
    msgs = one_msg msg;
    send msgs
end



  (*@return the amount of wei raised.*)
transition weiRaised()
    w<-_weiRaised;
    msg = {_tag : "Main"; _recipient : _sender; _amount : Uint128 0; weiRaised : w};
    msgs = one_msg msg;
    send msgs
end



transition buyTokens( beneficiary: ByStr20) 
  s<-sale;
  r<-_rate;
  b<-balances;
  wlt<-_wallet;
  bal = builtin get b _sender;
  match bal with
  | Some m =>
    new_bal = builtin sub m _amount;
    new_balances = builtin put b _sender new_bal;
    balances := new_balances;
    new_bal1 = builtin add m _amount;
    new_balances1 = builtin put b wlt new_bal1;
    balances := new_balances1;
  
   weiAmount = buitin mul _amount r ;
  _new_weiRaised<-_weiRaised;
  val = builtin eq beneficiary _wallet;
  match val with
  | True =>
      val1 = builtin eq weiAmount _zero;
      match val1 with
     | True =>
         new_sale = builtin put s beneficiary weiAmount;
         _new_weiRaised = builtin add_new_weiRaised weiAmount;
         _weiRaised:=_new_weiRaised;
         sale:=new_sale;
         msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; code : success };
         msgs = one_msg msg;
         send msgs
     | False =>
         msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; code : failed };
         msgs = one_msg msg;
         send msgs
         end
     
  | False =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; code : failed };
    msgs = one_msg msg;
    send msgs
  end
  
  
  | None =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; code: low_bal };
    msgs = one_msg msg;
    send msgs
  
  
end
end

    
    
  

 
(* This contract implements a Escrow contract*)
(* This contract does not fire events *)


(***************************************************)
(*               Associated library                *)
(***************************************************)
library RefundableCrowdsale
let equal_int=
  fun(a : Uint128) => fun(b:Uint128) =>
  let equal= builtin eq a b in
  match equal with
  | True =>True
  | False =>False
  end
let zero = Uint128 0
let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let no_msg = Nil {Message}

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end
    

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract RefundableCrowdsale
(payee : ByStr20,
 deposits : Uint128,
 _rate:Uint128)

(* Initial balance is not stated explicitly: it's initialized when creating the contract. *)

field all_deposits : Map ByStr20 Uint128 =
  let m = Emp ByStr20 Uint128 in
    builtin put m payee deposits
field token : Map ByStr20 Uint128 = Emp ByStr20 Uint128




transition deposit ()
  bl <- all_deposits;
  s <- token;
  bal = builtin get bl _sender;
  val = builtin eq _sender payee;
  match val with
  | False =>
    val1=equal_int _amount zero;
    match val1 with 
    | False =>
      number_of_token = builtin mul _rate _amount; 
      
          
      
      match bal with
      | Some b =>
        can_do = le_int _amount b;
        match can_do with
        | True =>
          (* subtract deposit from _sender and add it to payee *)
          tk=builtin get s _sender;
          match tk with 
          | Some x =>
            new_to_tk_bal=builtin add x number_of_token;
            new_tk_bal=builtin put s _sender new_to_tk_bal;
            token := new_tk_bal
          | None =>
            new_tk_bal1=builtin put s _sender number_of_token;
            token := new_tk_bal1
          end;  
          new_sender_bal = builtin sub b _amount;
          new_balances = builtin put bl _sender new_sender_bal;
          to_bal = builtin get new_balances payee;
          match to_bal with
          | Some x =>
            new_to_bal = builtin add x _amount;
            new_balances2 = builtin put new_balances payee new_to_bal;
            all_deposits := new_balances2
          | None =>
            new_balances3 = builtin put new_balances payee _amount;
            all_deposits := new_balances3
          end;
    
          msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : _amount };        msgs = one_msg msg;
          send msgs
        | False =>
          (* balance not sufficient. *)
          msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
          msgs = one_msg msg;
          send msgs
        end
      | None =>
        (* no balance record, can't transfer *)
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
        msgs = one_msg msg;
        send msgs
      end
    | True =>
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
      msgs = one_msg msg;
      send msgs 
    end  
  | True =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 };
    msgs = one_msg msg;
    send msgs  
  end        
 
end


(***************************************************)
(*               Associated library                *)
(***************************************************)

import BoolUtils

library SecurityToken 

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let no_msg = Nil {Message}

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uin128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end
    



(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract SecurityToken 
(name:String ,
 symbol: String,
 totalSupply:Uint128,
 owner : ByStr20)

(* Initial balance is not stated explicitly: it's initialized when creating the contract. *)

field balances : Map ByStr20 Uint256 =
  let m = Emp ByStr20 Uint256 in
    builtin put m owner totalSupply

field _totalSupply: Uint128 = totalSupply
  
(* Mapping from investor to their tranches (address -> amount tranche)*)
field tranches : Map ByStr20 (Map Uint256 Int32) = Emp ByStr20 (Map Uint256 Int32)

(* Mapping from (investor, tranche) to index of corresponding tranche in tranches*)
field trancheToIndex : Map ByStr20 (Map Int32 Uint256) = Emp ByStr20 (Map Int32 Uint256)

(* Mapping from (investor, tranche, operator) to approved status*)
field trancheApprovals : Map ByStr20 (Map Int32 (Map ByStr20 Int32)) = Emp ByStr20 (Map Int32 (Map ByStr20 Int32))

(* Mapping from (investor, operator) to approved status (can be used against any tranches)*)
field approvals : Map ByStr20 (Map ByStr20 bool) = Emp ByStr20 (Map ByStr20 bool)

 
 
transition name()
 msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; name : name};
  msgs = one_msg msg;
  send msgs
end

transition symbol()
 msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; symbol : symbol};
  msgs = one_msg msg;
  send msgs
end


transition totalSupply ()
  t<-_totalSupply;
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; totalSupply : t};
  msgs = one_msg msg;
  send msgs
 end


transition balanceOf (_owner : ByStr20)
  bl <- balances;
  val = builtin get bl _owner;
  match val with
  | Some v =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : v };
    msgs = one_msg msg;
    send msgs
  | None =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : Uint128 0 };
    msgs = one_msg msg;
    send msgs
  end
end 

(*return tranches[_owner][trancheToIndex[_owner][_tranche]].amount;*)
(*Returns restricted token balance*)

transition balanceOfTranche ( _tranche: Int32  ,_owner : ByStr20)
  tr <- trancheToIndex;
  val = builtin get tr _owner;
  match val with
  | Some v =>
    bl = builtin get val _tranche;
    match bl with
    | Some v1 => v1
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint256 0; bal : v1 };
    msgs = one_msg msg;
    send msgs
    
    | None =>Uint256 0
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : Uint256 0 };
    msgs = one_msg msg;
    send msgs
    end

  | None =>Uint256 0
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : Uint256 0 };
    msgs = one_msg msg;
    send msgs
  end
end





(*Transfers the ownership of tokens from a specified tranche from one address to another address*)
(*@param _tranche The tranche from which to transfer tokens*)
(*@param _to The address to which to transfer tokens to*)
(*@param amount The amount of tokens to transfer from `_tranche`*)
(*@param _data Additional data attached to the transfer of tokens*)
(*@return A reason code related to the success of the send operation*)
(*@return The tranche to which the transferred tokens were allocated for the _to address*)
   
(* Transfers tokens from the sender to the _to address, keeping the _tranche the same*)
   
transition sendTranche (_tranche : Uint32, _to : ByStr20, amount:Uint256, _data:String )

r_code= le_int balanceOfTranche(msg.sender, _tranche)  _amount) 
match r_code with  
    | True=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; reason_code :String "00"};
  msgs = one_msg msg;
  send msgs
    | False=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; reason_code :String "00"};
  msgs = one_msg msg;
  send msgs
    end
    

r_code1= le_int tranches[_from][trancheToIndex[msg.sender][_tranche]].amount - _amount
                                       tranches[_from][trancheToIndex[msg.sender][_tranche]].amount ) 
match r_code1 with  
    | True=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; reason_code :String "10"};
  msgs = one_msg msg;
  send msgs
    | False=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; reason_code :String "00"};
  msgs = one_msg msg;
  send msgs
    end
    

r_code2= le_int tranches[_from][trancheToIndex[msg.sender][_tranche]].amount - _amount 
                                       tranches[_from][trancheToIndex[msg.sender][_tranche]].amount ) 
match r_code1 with  
    | True=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; reason_code :String "10"};
  msgs = one_msg msg;
  send msgs
    | False=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; reason_code :String "00"};
  msgs = one_msg msg;
  send msgs
    end


    al <- allowed;
    
    is_operator=builtin eq operator _sender;
    match is_operator with
    | True=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized :noauth};
  msgs = one_msg msg;
  send msgs
    | False=>
        allowed_operators = let m = Emp ByStr20 Uint128 in builtin put m _sender totalSupply ;
        allowed_new = builtin put al operator allowed_operators;
        allowed := allowed_new;
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : auth};
  msgs = one_msg msg;
  send msgs

    end
end




transition operatorSendTranche (_tranche : Uint32,_from : ByStr20, _to : ByStr20, _amount:Uint256, _data:String, _operatorData:String )
    al <- allowed;
    
    auth="authorized";
    noauth="authorize failed";
    
    is_operator=builtin eq operator _sender;
    match is_operator with
    | True=>
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized :noauth};
  msgs = one_msg msg;
  send msgs
    | False=>
        allowed_operators = let m = Emp ByStr20 Uint128 in builtin put m _sender totalSupply ;
        allowed_new = builtin put al operator allowed_operators;
        allowed := allowed_new;
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : auth};
  msgs = one_msg msg;
  send msgs

    end
end



         (*return tranches[_owner][_index].tranche;*)
transition trancheByIndex (_owner : ByStr20,_index:Uint256)
   
end



transition tranchesOf (_owner : ByStr20)

    tr <- tranches;
    get_owner=builtin get tr tranch;
    match get_owner with
    | Some v=>
     msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; total : v};
     msgs = one_msg msg;
     send msgs
     | None=>
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; total : Uint128 0};
        msgs = one_msg msg;
        send msgs
      end
end


(* returns (address[])*)

transition defaultOperators ()
(* No default operators*)
     msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; default : owner};
     msgs = one_msg msg;
     send msgs
end


transition defaultOperatorsTranche (_tranche:String)
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; default : owner};
    msgs = one_msg msg;
    send msgs
end



transition authorizeOperator ( operator : ByStr20)
   
  ap <- approvals;
  op = builtin get ap _sender;
  match op with
  | Some m =>
        new_approvals = builtin put m operator true;
        approvals := new_approvals;
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : bool true  };
        msgs = one_msg msg;
        send msgs
       
 | None=>
        new_sender=builtin put ap _sender operator;
        new_approvals = builtin put new_sender operator true;
        approvals := new_approvals;
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : bool true };
        msgs = one_msg msg;
        send msgs
    end
end


transition authorizeOperatorTranche ( operator : ByStr20,_tranche:Int32 )
  al <- allowed;
     is_op="Operator found";
     is_no_op="Operator found failed";

  has_operator = builtin get al operator;
  match has_operator with
  | Some m =>
      is_operator= builtin contains m tokenHolder;
      match is_operator with
          | True =>
              msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_op };
              msgs = one_msg msg;
              send msgs
          | False =>
              msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_no_op};
              msgs = one_msg msg;
              send msgs
              end
       
 | None=>
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_no_op };
        msgs = one_msg msg;
        send msgs
    end
end






transition revokeOperator ( operator : ByStr20)
  
  ap <- approvals;
  op = builtin get ap _sender;
  match op with
  | Some m =>
        new_approvals = builtin put m operator false;
        approvals := new_approvals;
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : bool false  };
        msgs = one_msg msg;
        send msgs
       
 | None=>
        new_sender=builtin put ap _sender operator;
        new_approvals = builtin put new_sender operator false;
        approvals := new_approvals;
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : bool false };
        msgs = one_msg msg;
        send msgs
    end
end



transition revokeOperatorTranche ( operator : ByStr20,_tranche:Int32 )
  al <- allowed;
     is_op="Operator found";
     is_no_op="Operator found failed";

  has_operator = builtin get al operator;
  match has_operator with
  | Some m =>
      is_operator= builtin contains m tokenHolder;
      match is_operator with
          | True =>
              msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_op };
              msgs = one_msg msg;
              send msgs
          | False =>
              msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_no_op};
              msgs = one_msg msg;
              send msgs
              end
       
 | None=>
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_no_op };
        msgs = one_msg msg;
        send msgs
    end
end



transition isOperatorFor ( operator : ByStr20, _owner : ByStr20)
  ap <- approvals;
  op = builtin get ap _sender;
  match op with
  | Some m =>
        op1 = builtin get m operator;
          match op with
          | Some m1 =>
          msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : m1  };
          msgs = one_msg msg;
          send msgs
          | None=>
          msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : bool false };
          msgs = one_msg msg;
          send msgs
      end
       
 | None=>
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; authorized : bool false };
        msgs = one_msg msg;
        send msgs
    end
end



transition isOperatorForTranche ( operator : ByStr20, _owner : ByStr20,_tranche:Int32)
  al <- allowed;
     is_op="Operator found";
     is_no_op="Operator found failed";

  has_operator = builtin get al operator;
  match has_operator with
  | Some m =>
      is_operator= builtin contains m _owner;
      match is_operator with
          | True =>
              msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_op };
              msgs = one_msg msg;
              send msgs
          | False =>
              msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_no_op};
              msgs = one_msg msg;
              send msgs
              end
       
 | None=>
        msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; isOperator : is_no_op };
        msgs = one_msg msg;
        send msgs
    end
end





transition burn (_tranche:Int32,_owner:ByStr20,_amount : Uint256 , _data : String)

isMultiple1= builtin div amount  granularity;
isMultiple2= builtin mul isMultiple1  granularity;
notgranular="Not granular";
insuffBal="Balance insuffuciient";
noBal="No balance record";

isMultiple=builtin eq isMultiple2 amount ;
 match  isMultiple with
  | True =>
      
      
  bl <- balances;
  bal = builtin get bl _sender;
  match bal with
  | Some b =>
    can_do = le_int amount b;
    match can_do with
    | True =>
      (* subtract amount from _sender and add it to to *)
      new_sender_bal = builtin sub b amount;
      new_balances = builtin put bl _sender new_sender_bal;
      balances := new_balances;

      t<-_totalSupply;
      _newSupply=builtin sub t amount;
      _totalSupply:=_newSupply;
      
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : _amount; data :data};
      msgs = one_msg msg;
      send msgs
    | False =>
      (* balance not sufficient. *)
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 ; data :insuffBal };
      msgs = one_msg msg;
      send msgs
    end
  | None =>
    (* no balance record, can't transfer *)
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 ; data :noBal};
    msgs = one_msg msg;
    send msgs
  end

| False =>
msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 ; message :notgranular};
msgs = one_msg msg;
send msgs
end
end


transition mint (_tranche:Int32,_owner:ByStr20,_amount : Uint256 , _data : String)

isMultiple1= builtin div amount  granularity;
isMultiple2= builtin mul isMultiple1  granularity;
notgranular="Not granular";
insuffBal="Balance insuffuciient";
noBal="No balance record";

isMultiple=builtin eq isMultiple2 amount ;
 match  isMultiple with
  | True =>
      
      
  bl <- balances;
  bal = builtin get bl _sender;
  match bal with
  | Some b =>
    can_do = le_int amount b;
    match can_do with
    | True =>
      (* subtract amount from _sender and add it to to *)
      new_sender_bal = builtin sub b amount;
      new_balances = builtin put bl _sender new_sender_bal;
      balances := new_balances;

      t<-_totalSupply;
      _newSupply=builtin sub t amount;
      _totalSupply:=_newSupply;
      
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : _amount; data :data};
      msgs = one_msg msg;
      send msgs
    | False =>
      (* balance not sufficient. *)
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 ; data :insuffBal };
      msgs = one_msg msg;
      send msgs
    end
  | None =>
    (* no balance record, can't transfer *)
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 ; data :noBal};
    msgs = one_msg msg;
    send msgs
  end

| False =>
msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; transferred : Uint128 0 ; message :notgranular};
msgs = one_msg msg;
send msgs
end
end


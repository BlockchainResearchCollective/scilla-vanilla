
(***************************************************)
(*               Associated library                *)
(***************************************************)

import BoolUtils ListUtils 

library Randao 

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let no_msg = Nil {Message}

let blk_leq =
  fun (blk1 : BNum) =>
  fun (blk2 : BNum) =>
    let bc1 = builtin blt blk1 blk2 in 
    let bc2 = builtin eq blk1 blk2 in 
    orb bc1 bc2

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end
   
let zero_opt =
  let z = Uint128 0 in
  Some {Uint128} z

(*Constants*)
let _zero   = Uint128 0
let _one   = Uint128 1
let _zero1   = Uint32 0
let _one1   = Uint32 1

(* Error events *)
let mk_error_event =
  fun (err_code : Int32) =>
    { _eventname : "RandaoError" ; err_code : err_code }

(* Error messages *)
let insufficient_deposit_err_code = Int32 -1
let early_commit_err_code  = Int32 -2
let deadline_finish_err_code = Int32 -3
let not_reveal_deadline_err_code = Int32 -4
let not_committed_err_code = Int32 -5
let early_reveal_err_code = Int32 -6
let reveal_deadline_not_ended_err_code = Int32 -7
let failure_err_code = Int32 -8
let failure_wrong_secret = Int32 -9
let bounty_unequal_err_code = Int32 -10
let not_founder_err_code = Int32 -11
let bounty_not_funded_err_code = Int32 -12


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Randao 
( founder : ByStr20, _deposit: Uint128, commitBalkline: BNum, commitDeadline: BNum, bnum: BNum, _bounty: Uint128, minParticipant : Uint128 )
(*_deposit is _amount of zil required to send to take part in commit phase*)
(*commitBalkline is the Bnum when the commit phase starts*)
(*commitDeadline is the Bnum when the commit phase ends*)
(*bnum is the Bnum when the reveal phase ends*)
(*between commitDeadline and bnum is the reveal phase*)
(*so commitBalkline < commitDeadline < bnum*)

(*address, commitment (i.e. sha256 hash of secret), secret *)
field participant :Map ByStr20 ( Map ByStr32 Uint128 ) = Emp ByStr20 ( Map ByStr32  Uint128 )
(*secret is initialized to zero in mapping*)

(*mapping for if address has revealed secret in reveal phase and is eligible for bounty*)
field revealed : Map ByStr20 Uint32 = Emp ByStr20 Uint32 

(*mapping for if address has been rewarded*)
field rewarded: Map ByStr20 Uint32 = Emp ByStr20 Uint32 

(*balance of Consumer in zil*)
(*founder is the account that has all _bounty at initialisation*)
field consumer : Map ByStr20 Uint128 =
  let m = Emp ByStr20 Uint128 in
    builtin put m founder _bounty

field commitNum : Option Uint128 = zero_opt
(*equal to zero at initialisation*)

field revealsNum : Option Uint128 = zero_opt
(*equal to zero at initialisation*)

(*random number is generated after reveal phase is over, initializes to zero*) 
field random: Option Uint128 = zero_opt

(*is paused until it is funded*)
field paused : Uint32 = _one1


(*deposit of bounty by founder*)
transition depositBounty()
isEqualToBounty = builtin eq _bounty _amount;
isFounder = builtin eq _sender founder;
match isFounder with 
  | True =>
    match isEqualToBounty with 
      | True =>
         accept;
         paused:=_zero1;
         e = { _eventname : "BountyReceived"; amount : _amount};
         event e
      | False =>
         e = mk_error_event bounty_unequal_err_code;
         event e 
        end
  | False =>
     e = mk_error_event not_founder_err_code;
     event e 
    end
end


(*commit sha256 hash (of secret) in commit phase*)
transition commit (_hs : ByStr32 )
(*if bounty is funded isPaused is false (0) *)
p<-paused;
isPaused = builtin eq p _one1;
isEqualDeposit= builtin eq _amount _deposit;
blk <- & BLOCKNUMBER;
(*in_time_start and in_time_end if true signifies that blk lies in commitBalkline and commitDeadline i.e. in phase1*)
in_time_start = builtin blt commitBalkline blk;
in_time_end = builtin blt blk commitDeadline;
match isPaused with 
  | False =>
match isEqualDeposit with
  | True =>
   match in_time_start with
    | True =>
	match in_time_end with
	  | True =>
	    accept;	    
 	    participant[_sender][_hs]:=_zero;
            revealed[_sender]:=_zero1;
	    rewarded[_sender]:=_zero1;
	    cn<-commitNum;
	    newCommitNum=builtin add cn _one;
            newCommitNumOpt = Some {Uint128} newCommitNum;
            commitNum:=newCommitNumOpt;
	    e = { _eventname : "LogCommit"; from : _sender ; commitment : _hs  };
	    event e
	  | False => 
	   e = mk_error_event deadline_finish_err_code;
           event e 
	   end
    | False => 
        e = mk_error_event early_commit_err_code;
        event e 
     end
  | False =>
   e = mk_error_event insufficient_deposit_err_code;
   event e 
  end
  | True =>
   e = mk_error_event bounty_not_funded_err_code;
   event e 
  end
end


(*returns commitment, sha256 hash of _sender*)
transition getCommitment ()
  valMap <- participant [_sender];
  match valMap with
  | Some v =>
    val=builtin to_list v;
    match val with 
   | Cons h t => 
      match h with
      | Pair a b => 
        e = { _eventname : "Commitment"; commitment : a  };
        event e
        end
   | Nil =>
    e = mk_error_event not_committed_err_code;
    event e 
    end
 | None=>
  e = mk_error_event not_committed_err_code;
  event e 
  end
end


(*reveal secret in reveal phase of commitment*)
transition reveal(_s : Uint128)
success="successful";
cn<-commitNum;
blk <- & BLOCKNUMBER;
(*in_time_start and in_time_end if true signifies that blk lies in commitBalkline and commitDeadline i.e. in phase1*)
isMinParticipants = le_int minParticipant cn;
in_time_start = blk_leq commitDeadline blk;
in_time_end = blk_leq blk bnum ;
match isMinParticipants with
| True =>
match in_time_start with
 | True =>
   match in_time_end with
   | True =>
      commit= builtin sha256hash _s;
      val5 <- participant [_sender];
      match val5 with
      | Some v5 =>
       val1=builtin get v5 commit ;
       match val1 with
 	 | Some v6 =>
	        rn<-revealsNum;
	        newRevealNum=builtin add rn _one;
                newRevealNumOpt = Some {Uint128} newRevealNum;
                revealsNum:=newRevealNumOpt;
	        (*generate random no.*)
	        prRandom<-random;
	        newRandom=builtin add prRandom _s;
                newRandomNumOpt = Some {Uint128} newRandom;
                random:=newRandomNumOpt;	
	        participant[_sender][commit] := _s;
	        revealed[_sender]:=_one1;
        	e = { _eventname : "LogReveal"; from : _sender  ; secret : _s  };
	        event e
	 | None =>
  	        e = mk_error_event failure_wrong_secret;
		event e
		end
      | None =>
       e = mk_error_event failure_err_code;
       event e 
       end
   | False => 
   e = mk_error_event deadline_finish_err_code;
   event e 
   end
 | False => 
   e = mk_error_event early_reveal_err_code;
   event e 
   end
| False => 
hash <- participant [_sender];
match hash with
  | Some v6 =>
  msg = { _tag : "Main"; _recipient : _sender; _amount : _deposit; status : "Failed compaign and refunded deposit as minParticipants < total commits" };
  msgs = one_msg msg;
  send msgs
  | None =>
  e = mk_error_event failure_err_code;
  event e 
  end
end
end



(*to get the reward after reveal phase is over*)
transition getMyBounty()
blk <- & BLOCKNUMBER;
isEnd=blk_leq bnum blk;
revealno<-revealsNum;
commitno<-commitNum;
match isEnd with
  | True =>
  isRevealed<-revealed[_sender];
  match isRevealed with
    |Some rv =>
    hasRevealed=builtin eq rv _one1;
    match hasRevealed with
      |True =>
      isRewarded<-rewarded[_sender];
      match isRewarded with
        |Some rv1 =>
        hasRewarded=builtin eq rv1 _one1;
        match hasRewarded with
          |False =>
	  diffRevealed=builtin sub commitno revealno;
	  isEqualRevealed=builtin eq diffRevealed _zero;
	  match isEqualRevealed with
	    |True =>
 	    distributionAmount=builtin div _bounty revealno;
 	    am<-consumer[founder];
            match am with
              |Some cAmt =>
 	      founderAmt=builtin sub cAmt distributionAmount;
 	      consumer[founder]:=founderAmt;
              am1<-consumer[_sender];
	      match am1 with
	        |Some cAmt1 =>
	        totalReward= builtin add distributionAmount _deposit;
 		senderAmt=builtin add cAmt1 totalReward;
 		consumer[_sender]:=senderAmt;
	        rewarded[_sender]:=_one1;
 		msg = { _tag : "Main"; _recipient : _sender; _amount : totalReward ; status : success };
    	        msgs = one_msg msg;
   	        send msgs
		|None=>
	        totalReward= builtin add distributionAmount _deposit;
 		senderAmt=totalReward;
		consumer[_sender]:=senderAmt;
	        rewarded[_sender]:=_one1;
 		msg = { _tag : "Main"; _recipient : _sender; _amount : totalReward; status : success };
		msgs = one_msg msg;
    		send msgs
 		end 
	     |None=>
	      e = mk_error_event failure_err_code;
	      event e 
              end 
		|False =>
		fine=builtin mul diffRevealed _deposit;
		distributionShare=builtin div _bounty revealno;
		distributionAmount=builtin add fine distributionShare;
	 	am<-consumer[founder];
		match am with
		  |Some cAmt =>
	 	  founderAmt = builtin sub cAmt distributionShare;
	 	  consumer[founder]:=founderAmt;
	 	  am1<-consumer[_sender];
		  match am1 with
		    |Some cAmt1 =>
          	     totalReward = builtin add distributionAmount _deposit;
 		     senderAmt = builtin add cAmt1 totalReward;
		     consumer[_sender]:=senderAmt;
	             rewarded[_sender]:=_one1;
	 	     msg = { _tag : "Main"; _recipient : _sender; _amount : totalReward; status : "success" };
	  	     msgs = one_msg msg;
	  	     send msgs
		   |None=>
		     totalReward = builtin add distributionAmount _deposit;
 		     senderAmt = totalReward;
	             consumer[_sender]:=senderAmt;
	             rewarded[_sender]:=_one1;
	 	     msg = { _tag : "Main"; _recipient : _sender; _amount : totalReward; status : "success" };
	   	     msgs = one_msg msg;
	    	     send msgs
	  	     end 
		|None=>
	 	 e = mk_error_event failure_err_code;
        	 event e 
	         end
		 end
  	   |True =>
  	    e = mk_error_event failure_err_code;
            event e 
            end 
        |None=>
        e = mk_error_event failure_err_code;
        event e 
        end 
     |False=>
	e = mk_error_event not_reveal_deadline_err_code;
        event e 
        end 
  |None=>
   e = mk_error_event not_committed_err_code;
   event e 
   end 
|False =>
 e = mk_error_event reveal_deadline_not_ended_err_code;
 event e 
 end 
end


(*random no. generated by contract*)
transition getRandom ()
blk <- & BLOCKNUMBER;
isEnd=blk_leq bnum blk;
r<-revealsNum;
rn<-random;
isConsumer= builtin eq _sender founder;
match isConsumer with
| True =>
  match isEnd with
  | True =>
   isSettled = le_int minParticipant r;
   match isSettled with
   | True =>
      e = { _eventname : "RandomNumber" ; number : rn  };
      event e
   | False =>
      e = mk_error_event failure_err_code;
      event e 
      end
  | False =>
    e = mk_error_event reveal_deadline_not_ended_err_code;
    event e 
    end
| False =>
   e = mk_error_event not_founder_err_code;
   event e 
   end
end

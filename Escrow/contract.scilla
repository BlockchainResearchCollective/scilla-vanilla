(* This contract implements a Escrow contract*)
(* This contract does not fire events *)


(***************************************************)
(*               Associated library                *)
(***************************************************)
library Escrow

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let no_msg = Nil {Message}

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end
    

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Escrow
(primary: ByStr20,
 payee : ByStr20,
 deposits : Uint128)

(* Initial balance is not stated explicitly: it's initialized when creating the contract. *)
field all_deposits : Map ByStr20 Uint128 =
  let m = Emp ByStr20 Uint128 in
    builtin put m payee deposits

(*may be initialized here by removing from immutable variable*)
field _primary: ByStr20 = primary

transition primary()
   p <- _primary;
   e = { _eventname : "Primary";  from : _sender ; primary : p   };
   event e
 end

  
transition transferPrimary(recipient : ByStr20)
   p <- _primary;
   notPrimary = "not primary";
   isPrimary=builtin eq _sender p;
   match isPrimary with
    | True =>
      _primary:=recipient;
       e = { _eventname : "Transfer Primary";  from : _sender ; recipient : recipient   };
       event e
    | False =>
       e = { _eventname : "Error";  from : _sender ; code : notPrimary  };
      event e
     end
end
  

transition depositsOf (payee : ByStr20)
 dep <- all_deposits;
  val = builtin get dep payee;
  match val with
  | Some v =>
    e = { _eventname : "DepositsOf";  from : _sender ; payee : payee ; deposits : v  };
    event e
  | None =>
    e = { _eventname : "DepositsOf";  from : _sender ; payee : payee ; deposits : _zero  };
    event e
  end
end


transition deposit (payee : ByStr20)
  deposits=_amount;
  bl <- all_deposits;
  noBal="no balance";
  inSuffBal= "inSufficient balance";
  bal = builtin get bl _sender;
  match bal with
  | Some b =>
    can_do = le_int deposits b;
    match can_do with
    | True =>
      (* subtract deposit from _sender and add it to payee *)
      new_sender_bal = builtin sub b deposits;
      new_balances = builtin put bl _sender new_sender_bal;
      to_bal = builtin get new_balances payee;
      match to_bal with
      | Some x =>
        new_to_bal = builtin add x deposits;
        new_balances2 = builtin put new_balances payee new_to_bal;
        all_deposits := new_balances2
        e = { _eventname : "Deposit";  from : _sender ; payee : payee };
        event e 
     | None =>
        new_balances3 = builtin put new_balances payee deposits;
        all_deposits := new_balances3
        e = { _eventname : "Deposit";  from : _sender ; payee : payee };
        event e
     end
    | False =>
      (* balance not sufficient. *)
    e = { _eventname : "Error";  from : _sender ; code : inSuffBal  };
    event e
    end
  | None =>
    (* no balance record, can't transfer *)
    e = { _eventname : "Error";  from : _sender ; code : noBal  };
    event e
  end
end



transition withdraw (payee : ByStr20)
  deposits=_amount;
  p <- _primary;
  noBal="no balance";
  notPrimary="not primary";
  inSuffBal= "inSufficient balance";
  isPrimary=builtin eq _sender p;
  match isPrimary with
   | True =>
    bl <- all_deposits;
    bal = builtin get bl payee;
    match bal with
     | Some b =>
      can_do = le_int deposits b;
      match can_do with
       | True =>
         (* subtract deposit from payee  and add it to  _sender*)
         new_sender_bal = builtin sub b deposits;
         new_balances = builtin put bl payee new_sender_bal;
         to_bal = builtin get new_balances _sender;
         match to_bal with
      | Some x =>
        new_to_bal = builtin add x deposits;
        new_balances2 = builtin put new_balances _sender new_to_bal;
        all_deposits := new_balances2
        e = { _eventname : "Withdraw";  from : _sender ; payee : payee };
        event e
      | None =>
        new_balances3 = builtin put new_balances _sender deposits;
        all_deposits := new_balances3
        e = { _eventname : "Withdraw";  from : _sender ; payee : payee };
        event e
      end
    | False =>
      (* balance not sufficient. *)
      e = { _eventname : "Error";  from : _sender ; code : inSuffBal  };
      event e
     end
  | None =>
    (* no balance record, can't transfer *)
    e = { _eventname : "Error";  from : _sender ; code : noBal  };
    event e
  end
  | False =>
    e = { _eventname : "Error"; from : _sender ; code : notPrimary  };
    event e
  end
end



